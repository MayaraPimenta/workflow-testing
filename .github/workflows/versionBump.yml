name: Version Bump on PR
on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches: [master, main]

permissions:
  contents: write
  pull-requests: write

jobs:
  version-bump:
    runs-on: ubuntu-latest
    steps:
      - name: Validate source branch
        id: validate_branch
        run: |
          SOURCE_BRANCH="${{ github.head_ref }}"
          echo "Source branch: $SOURCE_BRANCH"
          
          if [[ "$SOURCE_BRANCH" == "develop" ]] || [[ "$SOURCE_BRANCH" == hotfix* ]]; then
            echo "✅ Valid source branch: $SOURCE_BRANCH"
            echo "BRANCH_VALID=true" >> $GITHUB_ENV
          else
            echo "❌ Invalid source branch: $SOURCE_BRANCH"
            echo "PRs to main must come from 'develop' or branches starting with 'hotfix'"
            echo "BRANCH_VALID=false" >> $GITHUB_ENV
            exit 1
          fi

      - name: Check out the repository
        if: env.BRANCH_VALID == 'true'
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ github.event.pull_request.head.ref }}
          fetch-depth: 0

      - name: Setup Node.js
        if: env.BRANCH_VALID == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Get latest tag
        if: env.BRANCH_VALID == 'true'
        id: get_latest_tag
        run: |
          git fetch --tags
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "0.0.0")
          echo "Latest tag found: $LATEST_TAG"
          echo "LATEST_TAG=$LATEST_TAG" >> $GITHUB_ENV

      - name: Get PR labels
        if: env.BRANCH_VALID == 'true'
        id: get_labels
        run: |
          LABELS=$(gh pr view ${{ github.event.pull_request.number }} --json labels --jq '.labels[].name' | tr '\n' ' ')
          echo "PR Labels: $LABELS"
          echo "PR_LABELS=$LABELS" >> $GITHUB_ENV
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Determine version bump type
        if: env.BRANCH_VALID == 'true'
        id: determine_bump
        run: |
          # Default to patch increment for all PRs
          BUMP_TYPE="patch"
          
          # Override with specific labels if present
          if echo "${{ env.PR_LABELS }}" | grep -q "major\|breaking"; then
            BUMP_TYPE="major"
          elif echo "${{ env.PR_LABELS }}" | grep -q "minor\|feature"; then
            BUMP_TYPE="minor"
          fi
          
          echo "Version bump type: $BUMP_TYPE"
          echo "BUMP_TYPE=$BUMP_TYPE" >> $GITHUB_ENV

      - name: Calculate new version
        if: env.BRANCH_VALID == 'true'
        id: calc_version
        run: |
          CURRENT_VERSION="${{ env.LATEST_TAG }}"
          CURRENT_VERSION=${CURRENT_VERSION#v}
          
          # Get current package.json version for comparison
          PACKAGE_VERSION=$(node -p "require('./package.json').version" 2>/dev/null || echo "0.0.0")
          
          IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
          MAJOR=${VERSION_PARTS[0]:-0}
          MINOR=${VERSION_PARTS[1]:-0}
          PATCH=${VERSION_PARTS[2]:-0}
          
          # Use the higher version between git tag and package.json as base
          IFS='.' read -ra PACKAGE_PARTS <<< "$PACKAGE_VERSION"
          PKG_MAJOR=${PACKAGE_PARTS[0]:-0}
          PKG_MINOR=${PACKAGE_PARTS[1]:-0}
          PKG_PATCH=${PACKAGE_PARTS[2]:-0}
          
          # Compare versions and use the higher one
          if [ "$PKG_MAJOR" -gt "$MAJOR" ] || 
             ([ "$PKG_MAJOR" -eq "$MAJOR" ] && [ "$PKG_MINOR" -gt "$MINOR" ]) || 
             ([ "$PKG_MAJOR" -eq "$MAJOR" ] && [ "$PKG_MINOR" -eq "$MINOR" ] && [ "$PKG_PATCH" -gt "$PATCH" ]); then
            # Package.json version is higher, use it
            MAJOR=$PKG_MAJOR
            MINOR=$PKG_MINOR
            PATCH=$PKG_PATCH
            echo "Using package.json version $PACKAGE_VERSION as base (higher than git tag $CURRENT_VERSION)"
          elif [ "$MAJOR" -gt "$PKG_MAJOR" ] || 
               ([ "$MAJOR" -eq "$PKG_MAJOR" ] && [ "$MINOR" -gt "$PKG_MINOR" ]) || 
               ([ "$MAJOR" -eq "$PKG_MAJOR" ] && [ "$MINOR" -eq "$PKG_MINOR" ] && [ "$PATCH" -gt "$PKG_PATCH" ]); then
            # Git tag version is higher, keep using it
            echo "Using git tag version $CURRENT_VERSION as base (higher than package.json $PACKAGE_VERSION)"
          else
            # Versions are equal
            echo "Git tag and package.json versions are equal: $CURRENT_VERSION"
          fi
          
          case "${{ env.BUMP_TYPE }}" in
            "major")
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            "minor")
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            "patch")
              PATCH=$((PATCH + 1))
              ;;
          esac
          
          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          echo "Current package.json version: $PACKAGE_VERSION"
          echo "New version: $NEW_VERSION"
          echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_ENV

      - name: Update package.json version
        if: env.BRANCH_VALID == 'true'
        run: |
          if [ -f "package.json" ]; then
            CURRENT_PKG_VERSION=$(node -p "require('./package.json').version")
            if [ "$CURRENT_PKG_VERSION" != "${{ env.NEW_VERSION }}" ]; then
              npm version ${{ env.NEW_VERSION }} --no-git-tag-version
              echo "Updated package.json version from $CURRENT_PKG_VERSION to ${{ env.NEW_VERSION }}"
            else
              echo "Version is already ${{ env.NEW_VERSION }}, no update needed"
            fi
          fi

      - name: Commit version update to PR branch
        if: env.BRANCH_VALID == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          if ! git diff --quiet; then
            git add package.json
            git commit -m "chore: bump version to ${{ env.NEW_VERSION }}"
            git push origin ${{ github.event.pull_request.head.ref }}
            echo "Committed version update to PR branch"
          else
            echo "No changes to commit"
          fi

      - name: Create version update branch and PR (for protected branches)
        if: env.BRANCH_VALID == 'true' && env.PROTECTED_BRANCH == 'true'
        run: |
          if ! git diff --quiet; then
            # Create a new branch for the version update
            VERSION_BRANCH="version-bump-${{ env.NEW_VERSION }}-$(date +%s)"
            git checkout -b "$VERSION_BRANCH"
            
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            
            git add package.json
            git commit -m "chore: bump version to ${{ env.NEW_VERSION }}"
            git push origin "$VERSION_BRANCH"
            
            # Create a PR to merge the version update back to the source branch
            PR_URL=$(gh pr create \
              --title "chore: bump version to ${{ env.NEW_VERSION }}" \
              --body "Automated version bump from #${{ github.event.pull_request.number }}.\n\nThis PR updates the version in package.json to ${{ env.NEW_VERSION }}.\n\n**This PR will be automatically merged.**" \
              --base "${{ github.head_ref }}" \
              --head "$VERSION_BRANCH")
            
            echo "✅ Created version bump PR: $PR_URL"
            
            # Wait a moment for the PR to be fully created
            sleep 5
            
            # Get the PR number from the URL
            PR_NUMBER=$(echo "$PR_URL" | grep -o '[0-9]*$')
            
            # Auto-merge the PR
            # Force merge immediately (bypasses checks)
            gh pr merge "$PR_NUMBER" --squash --delete-branch
            
            echo "✅ Version bump PR #$PR_NUMBER has been set to auto-merge"
            echo "🔄 The version will be updated automatically once checks pass"
          else
            echo "No changes to commit"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}