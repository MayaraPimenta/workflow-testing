name: New Release

on:
  pull_request:
    types: [closed]
    branches: [master, main]

permissions:
  pull-requests: read
  contents: write
  actions: read

jobs:
  release:
    if: github.event.pull_request.merged == true 
    runs-on: ubuntu-latest
    steps:
      - name: Check out the repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Get latest tag
        id: get_latest_tag
        run: |
          # Get the latest tag, default to 0.0.0 if no tags exist
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "0.0.0")
          echo "Latest tag found: $LATEST_TAG"
          echo "LATEST_TAG=$LATEST_TAG" >> $GITHUB_ENV

      - name: Get PR labels
        id: get_labels
        run: |
          # Get PR labels using GitHub API
          LABELS=$(gh pr view ${{ github.event.pull_request.number }} --json labels --jq '.labels[].name' | tr '\n' ' ')
          echo "PR Labels: $LABELS"
          echo "PR_LABELS=$LABELS" >> $GITHUB_ENV
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Determine version bump type
        id: determine_bump
        run: |
          BUMP_TYPE="patch"
          
          # Check for version bump labels
          if echo "${{ env.PR_LABELS }}" | grep -q "major\|breaking"; then
            BUMP_TYPE="major"
          elif echo "${{ env.PR_LABELS }}" | grep -q "minor\|feature"; then
            BUMP_TYPE="minor"
          elif echo "${{ env.PR_LABELS }}" | grep -q "patch\|fix\|bugfix"; then
            BUMP_TYPE="patch"
          fi
          
          echo "Version bump type: $BUMP_TYPE"
          echo "BUMP_TYPE=$BUMP_TYPE" >> $GITHUB_ENV

      - name: Calculate new version
        id: calc_version
        run: |
          # Parse current version
          CURRENT_VERSION="${{ env.LATEST_TAG }}"
          # Remove 'v' prefix if present
          CURRENT_VERSION=${CURRENT_VERSION#v}
          
          # Split version into components
          IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
          MAJOR=${VERSION_PARTS[0]:-0}
          MINOR=${VERSION_PARTS[1]:-0}
          PATCH=${VERSION_PARTS[2]:-0}
          
          # Bump version based on type
          case "${{ env.BUMP_TYPE }}" in
            "major")
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            "minor")
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            "patch")
              PATCH=$((PATCH + 1))
              ;;
          esac
          
          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          echo "New version: $NEW_VERSION"
          echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_ENV

      - name: Get commits since last release grouped by PR
        id: get_commits
        run: |
          echo "Getting commits since last tag: ${{ env.LATEST_TAG }}"
          
          # Get commits since last tag
          if [ "${{ env.LATEST_TAG }}" = "0.0.0" ]; then
            # If no previous tags, get all commits
            COMMIT_RANGE="HEAD"
          else
            COMMIT_RANGE="${{ env.LATEST_TAG }}..HEAD"
          fi
          
          # Get all commits with their PR numbers
          echo "Getting commits and their associated PRs..."
          
          # Create temporary files to store PR data
          TEMP_DIR=$(mktemp -d)
          COMMITS_FILE="$TEMP_DIR/commits.txt"
          PRS_FILE="$TEMP_DIR/prs.txt"
          
          # Get commits with format: hash subject
          git log --pretty=format:"%H|%s" $COMMIT_RANGE --reverse > "$COMMITS_FILE"
          
          if [ ! -s "$COMMITS_FILE" ]; then
            echo "No commits found since last release"
            echo "FORMATTED_COMMITS=No changes since last release." >> $GITHUB_ENV
            exit 0
          fi
          
          # Get all merged PRs since last tag
          echo "Getting merged PRs..."
          gh pr list --state merged --limit 100 --json number,title,mergeCommit,commits > "$PRS_FILE"
          
          # Process commits and group by PR
          FORMATTED_COMMITS=""
          MISC_COMMITS=""
          declare -A PROCESSED_PRS
          
          while IFS='|' read -r COMMIT_HASH COMMIT_MESSAGE; do
            if [ -z "$COMMIT_HASH" ] || [ -z "$COMMIT_MESSAGE" ]; then
              continue
            fi
            
            echo "Processing commit: $COMMIT_HASH $COMMIT_MESSAGE"
            
            # Skip version bump commits
            if [[ "$COMMIT_MESSAGE" =~ ^chore:\ bump\ version ]]; then
              continue
            fi
            
            # Find which PR this commit belongs to
            PR_NUMBER=""
            PR_TITLE=""
            
            # Check if this commit is a merge commit of a PR
            if [[ "$COMMIT_MESSAGE" =~ ^Merge\ pull\ request\ #([0-9]+) ]]; then
              PR_NUMBER="${BASH_REMATCH[1]}"
              echo "Found merge commit for PR #$PR_NUMBER"
              continue
            fi
            
            # Search for PR that contains this commit
            while read -r pr_data; do
              if echo "$pr_data" | jq -e ".commits[]? | select(.oid == \"$COMMIT_HASH\")" > /dev/null 2>&1; then
                PR_NUMBER=$(echo "$pr_data" | jq -r '.number')
                PR_TITLE=$(echo "$pr_data" | jq -r '.title')
                echo "Commit $COMMIT_HASH belongs to PR #$PR_NUMBER: $PR_TITLE"
                break
              fi
            done < <(jq -c '.[]' "$PRS_FILE" 2>/dev/null || echo "[]")
            
            if [ -n "$PR_NUMBER" ] && [ -z "${PROCESSED_PRS[$PR_NUMBER]}" ]; then
              echo "Processing PR #$PR_NUMBER for the first time"
              PROCESSED_PRS[$PR_NUMBER]="1"
              
              # Get all commits for this PR
              PR_COMMITS=$(gh pr view "$PR_NUMBER" --json commits --jq '.commits[].messageHeadline')
              
              # Check if any commit in this PR starts with [sc-xxxxx] or sc-xxxxx
              SC_COMMIT=""
              OTHER_COMMITS=""
              
              while IFS= read -r pr_commit; do
                if [ -z "$pr_commit" ]; then
                  continue
                fi
                
                # Check for [sc-xxxxx] or sc-xxxxx pattern
                if [[ "$pr_commit" =~ ^\[sc-[0-9]+\]|^sc-[0-9]+ ]]; then
                  SC_COMMIT="$pr_commit"
                  echo "Found SC commit: $SC_COMMIT"
                else
                  if [ -n "$OTHER_COMMITS" ]; then
                    OTHER_COMMITS="$OTHER_COMMITS"$'\n'"$pr_commit"
                  else
                    OTHER_COMMITS="$pr_commit"
                  fi
                fi
              done <<< "$PR_COMMITS"
              
              # Format the PR section
              if [ -n "$SC_COMMIT" ]; then
                # Use SC commit as title
                FORMATTED_COMMITS+="\n\n📝 $SC_COMMIT"
                if [ -n "$OTHER_COMMITS" ]; then
                  while IFS= read -r commit; do
                    if [ -n "$commit" ]; then
                      FORMATTED_COMMITS+="\n$commit"
                    fi
                  done <<< "$OTHER_COMMITS"
                fi
              else
                # No SC commit, add all commits to misc section
                if [ -n "$OTHER_COMMITS" ]; then
                  if [ -n "$MISC_COMMITS" ]; then
                    MISC_COMMITS="$MISC_COMMITS"$'\n'"$OTHER_COMMITS"
                  else
                    MISC_COMMITS="$OTHER_COMMITS"
                  fi
                fi
              fi
            fi
            
          done < "$COMMITS_FILE"
          
          # Add misc commits section if there are any
          if [ -n "$MISC_COMMITS" ]; then
            FINAL_FORMATTED="\n\n🗒️ Alterações sem identificação de card"
            while IFS= read -r commit; do
              if [ -n "$commit" ]; then
                FINAL_FORMATTED+="\n$commit"
              fi
            done <<< "$MISC_COMMITS"
            FINAL_FORMATTED+="$FORMATTED_COMMITS"
            FORMATTED_COMMITS="$FINAL_FORMATTED"
          fi
          
          # Remove leading newlines
          FORMATTED_COMMITS=${FORMATTED_COMMITS#$'\n'}
          FORMATTED_COMMITS=${FORMATTED_COMMITS#$'\n'}
          
          # Clean up temp files
          rm -rf "$TEMP_DIR"
          
          # Save to environment variable
          {
            echo 'FORMATTED_COMMITS<<EOF'
            echo -e "$FORMATTED_COMMITS"
            echo 'EOF'
          } >> $GITHUB_ENV
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: "v${{ env.NEW_VERSION }}"
          name: "Release v${{ env.NEW_VERSION }}"
          body: |
            🚀 **Nova versão ${{ env.NEW_VERSION }} lançada!**
            
            **Tipo de release:** ${{ env.BUMP_TYPE }}
            
            ## 📋 Alterações
            ${{ env.FORMATTED_COMMITS }}
            
            ---
            
            **Merge da PR:** #${{ github.event.pull_request.number }} - ${{ github.event.pull_request.title }}
          draft: false
          prerelease: false
          generate_release_notes: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Summary
        run: |
          echo "### 🎉 Release Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Version:** v${{ env.NEW_VERSION }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Bump Type:** ${{ env.BUMP_TYPE }}" >> $GITHUB_STEP_SUMMARY
          echo "- **PR:** #${{ github.event.pull_request.number }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Labels:** ${{ env.PR_LABELS }}" >> $GITHUB_STEP_SUMMARY