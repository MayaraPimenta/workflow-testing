name: New Release
on:
  pull_request:
    types: [closed]
    branches: [master, main]

permissions:
  pull-requests: write
  contents: write
  actions: read

jobs:
  release:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    steps:
      - name: Check out the repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          registry-url: 'https://registry.npmjs.org'

      - name: Get package.json version
        run: |
          echo "Getting updated version during PR process"
          if [ -f "package.json" ]; then
            NEW_VERSION=$(node -p "require('./package.json').version")
            echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_ENV
            echo "Using version from package.json: $NEW_VERSION"
          else
            echo "package.json not found, using calculated version"
          fi

      - name: Get commits for release notes
        id: get_commits
        run: |
          echo "Getting commits for release notes..."
          
          # Determine the base branch (the target branch of the PR)
          BASE_BRANCH="${{ github.event.pull_request.base.ref }}"
          HEAD_BRANCH="${{ github.event.pull_request.head.ref }}"
          
          echo "Base branch: $BASE_BRANCH"
          echo "Head branch: $HEAD_BRANCH"
          
          echo "Getting commits from this PR only..."
          
          # Get all merge commits from this specific PR range
          MERGE_COMMITS=$(git log --merges --pretty=format:"%H" ${{ github.event.pull_request.base.sha }}..${{ github.event.pull_request.head.sha }} 2>/dev/null || echo "")
          
          FORMATTED_COMMITS=""
          PROCESSED_BRANCHES=""
          
          if [ -z "$MERGE_COMMITS" ]; then
            echo "No merge commits found, treating as direct commits to develop"
            # Get commits from this PR only (between base and head)
            ALL_COMMITS=$(git log --pretty=format:"%h %s" ${{ github.event.pull_request.base.sha }}..${{ github.event.pull_request.head.sha }} --no-merges --reverse 2>/dev/null || echo "")
            
            if [ -n "$ALL_COMMITS" ]; then
              # Filter out version bump commits
              FILTERED_COMMITS=$(echo "$ALL_COMMITS" | grep -v "^[a-f0-9]* chore: bump version")
              
              if [ -n "$FILTERED_COMMITS" ]; then
                # Get the latest commit as title
                LATEST_COMMIT=$(echo "$FILTERED_COMMITS" | tail -1)
                LATEST_MESSAGE=$(echo "$LATEST_COMMIT" | cut -d' ' -f2-)
                
                FORMATTED_COMMITS="**$LATEST_MESSAGE**"
                
                # Add other commits as bullet points (if any)
                OTHER_COMMITS=$(echo "$FILTERED_COMMITS" | head -n -1)
                if [ -n "$OTHER_COMMITS" ]; then
                  while IFS= read -r commit; do
                    if [ -n "$commit" ]; then
                      COMMIT_MESSAGE=$(echo "$commit" | cut -d' ' -f2-)
                      FORMATTED_COMMITS+="\n- $COMMIT_MESSAGE"
                    fi
                  done <<< "$OTHER_COMMITS"
                fi
              fi
            fi
          else
            echo "Processing merge commits from this PR..."
            
            while IFS= read -r merge_hash; do
              if [ -z "$merge_hash" ]; then
                continue
              fi
              
              echo "Processing merge commit: $merge_hash"
              
              # Get the merge commit message to extract branch info
              MERGE_MESSAGE=$(git log --pretty=format:"%s" -1 $merge_hash 2>/dev/null || echo "")
              
              # Extract branch name from merge message
              BRANCH_NAME=""
              if [[ "$MERGE_MESSAGE" =~ Merge\ branch\ \'([^\']+)\' ]]; then
                BRANCH_NAME="${BASH_REMATCH[1]}"
              elif [[ "$MERGE_MESSAGE" =~ Merge\ pull\ request.*from.*\/([^\ ]+) ]]; then
                BRANCH_NAME="${BASH_REMATCH[1]}"
              fi
              
              if [ -n "$BRANCH_NAME" ]; then
                # Skip if branch name is the same as base or head branch to avoid conflicts
                if [ "$BRANCH_NAME" = "$BASE_BRANCH" ] || [ "$BRANCH_NAME" = "$HEAD_BRANCH" ]; then
                  echo "Skipping branch $BRANCH_NAME as it matches base or head branch"
                  continue
                fi
                
                # Skip if we already processed this branch
                if [[ "$PROCESSED_BRANCHES" =~ $BRANCH_NAME ]]; then
                  continue
                fi
                
                PROCESSED_BRANCHES+=" $BRANCH_NAME"
                
                echo "Getting commits from merged branch: $BRANCH_NAME"
                
                # Get commits from the merged branch only (commits that were merged in this specific merge)
                # Use the merge base to find only the commits that were added by this branch
                MERGE_BASE=$(git merge-base ${merge_hash}^1 ${merge_hash}^2 2>/dev/null || echo "")
                
                if [ -n "$MERGE_BASE" ]; then
                  # Get commits between merge base and the tip of the merged branch
                  ALL_BRANCH_COMMITS=$(git log --pretty=format:"%h %s" ${MERGE_BASE}..${merge_hash}^2 --no-merges --reverse 2>/dev/null || echo "")
                else
                  # Fallback: get commits from the second parent (merged branch)
                  ALL_BRANCH_COMMITS=$(git log --pretty=format:"%h %s" ${merge_hash}^2 --no-merges --reverse --max-count=10 2>/dev/null || echo "")
                fi
                
                if [ -n "$ALL_BRANCH_COMMITS" ]; then
                  # Filter out version bump commits only
                  FILTERED_BRANCH_COMMITS=$(echo "$ALL_BRANCH_COMMITS" | grep -v "^[a-f0-9]* chore: bump version")
                  
                  if [ -n "$FILTERED_BRANCH_COMMITS" ]; then
                    # Get the latest commit as title (last in chronological order)
                    LATEST_COMMIT=$(echo "$FILTERED_BRANCH_COMMITS" | tail -1)
                    LATEST_MESSAGE=$(echo "$LATEST_COMMIT" | cut -d' ' -f2-)
                    
                    echo "Latest commit from $BRANCH_NAME: $LATEST_MESSAGE"
                    
                    # Add section for this branch
                    if [ -n "$FORMATTED_COMMITS" ]; then
                      FORMATTED_COMMITS+="\n\n"
                    fi
                    FORMATTED_COMMITS+="**$LATEST_MESSAGE**"
                    
                    # Add other commits as bullet points (if any)
                    OTHER_COMMITS=$(echo "$FILTERED_BRANCH_COMMITS" | head -n -1)
                    if [ -n "$OTHER_COMMITS" ]; then
                      while IFS= read -r commit; do
                        if [ -n "$commit" ]; then
                          COMMIT_MESSAGE=$(echo "$commit" | cut -d' ' -f2-)
                          FORMATTED_COMMITS+="\n- $COMMIT_MESSAGE"
                        fi
                      done <<< "$OTHER_COMMITS"
                    fi
                  else
                    echo "No valid commits found for branch: $BRANCH_NAME (after filtering version bumps)"
                  fi
                else
                  echo "No commits found for branch: $BRANCH_NAME"
                fi
              else
                echo "Could not extract branch name from merge message: $MERGE_MESSAGE"
              fi
            done <<< "$MERGE_COMMITS"
          fi
          
          # Remove leading newline if present
          FORMATTED_COMMITS=${FORMATTED_COMMITS#\\n}
          
          # If still empty, add a default message
          if [ -z "$FORMATTED_COMMITS" ]; then
            echo "No commits found in this PR, using PR title as fallback"
            FORMATTED_COMMITS="**${{ github.event.pull_request.title }}**\n- Merged PR #${{ github.event.pull_request.number }}"
          fi
          
          echo "Final formatted commits:"
          echo -e "$FORMATTED_COMMITS"
          
          # Save to environment variable
          {
            echo 'FORMATTED_COMMITS<<EOF'
            echo -e "$FORMATTED_COMMITS"
            echo 'EOF'
          } >> $GITHUB_ENV

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: "v${{ env.NEW_VERSION }}"
          name: "Release v${{ env.NEW_VERSION }}"
          body: |
            ðŸš€ **Nova versÃ£o ${{ env.NEW_VERSION }} lanÃ§ada!**
            
            **Tipo de release:** ${{ env.BUMP_TYPE }}
            
            ## ðŸ“‹ AlteraÃ§Ãµes
            
            ${{ env.FORMATTED_COMMITS }}
            
            ---
            
            **Merge da PR:** #${{ github.event.pull_request.number }} - ${{ github.event.pull_request.title }}
            **Branch de origem:** ${{ github.event.pull_request.head.ref }}
            **Branch de destino:** ${{ github.event.pull_request.base.ref }}
          draft: false
          prerelease: false
          generate_release_notes: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Summary
        run: |
          echo "### ðŸŽ‰ Release Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Version:** v${{ env.NEW_VERSION }}" >> $GITHUB_STEP_SUMMARY
          echo "- **PR:** #${{ github.event.pull_request.number }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Labels:** ${{ env.PR_LABELS }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Base Branch:** ${{ github.event.pull_request.base.ref }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Head Branch:** ${{ github.event.pull_request.head.ref }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Package.json Updated:** âœ…" >> $GITHUB_STEP_SUMMARY
