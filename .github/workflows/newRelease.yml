name: New Release
on:
  pull_request:
    types: [closed]
    branches: [master, main]

permissions:
  pull-requests: write
  contents: write
  actions: read

jobs:
  add-release-label:
    if: github.event.pull_request.merged == true 
    runs-on: ubuntu-latest
    steps:
      - name: Add release label to PR
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              labels: ['release']
            });
            console.log('Added "release" label to PR #' + context.payload.pull_request.number);

  release:
    if: github.event.pull_request.merged == true 
    runs-on: ubuntu-latest
    needs: add-release-label
    steps:
      - name: Check out the repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Get latest tag
        id: get_latest_tag
        run: |
          # Get the latest tag, default to 0.0.0 if no tags exist
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "0.0.0")
          echo "Latest tag found: $LATEST_TAG"
          echo "LATEST_TAG=$LATEST_TAG" >> $GITHUB_ENV

      - name: Get PR labels
        id: get_labels
        run: |
          # Get PR labels using GitHub API
          LABELS=$(gh pr view ${{ github.event.pull_request.number }} --json labels --jq '.labels[].name' | tr '\n' ' ')
          echo "PR Labels: $LABELS"
          echo "PR_LABELS=$LABELS" >> $GITHUB_ENV
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Determine version bump type
        id: determine_bump
        run: |
          BUMP_TYPE="patch"
          
          # Check for version bump labels
          if echo "${{ env.PR_LABELS }}" | grep -q "major\|breaking"; then
            BUMP_TYPE="major"
          elif echo "${{ env.PR_LABELS }}" | grep -q "minor\|feature"; then
            BUMP_TYPE="minor"
          elif echo "${{ env.PR_LABELS }}" | grep -q "patch\|fix\|bugfix"; then
            BUMP_TYPE="patch"
          fi
          
          echo "Version bump type: $BUMP_TYPE"
          echo "BUMP_TYPE=$BUMP_TYPE" >> $GITHUB_ENV

      - name: Calculate new version
        id: calc_version
        run: |
          # Parse current version
          CURRENT_VERSION="${{ env.LATEST_TAG }}"
          # Remove 'v' prefix if present
          CURRENT_VERSION=${CURRENT_VERSION#v}
          
          # Split version into components
          IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
          MAJOR=${VERSION_PARTS[0]:-0}
          MINOR=${VERSION_PARTS[1]:-0}
          PATCH=${VERSION_PARTS[2]:-0}
          
          # Bump version based on type
          case "${{ env.BUMP_TYPE }}" in
            "major")
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            "minor")
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            "patch")
              PATCH=$((PATCH + 1))
              ;;
          esac
          
          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          echo "New version: $NEW_VERSION"
          echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_ENV

      - name: Get commits for release notes
        id: get_commits
        run: |
          echo "Getting commits for release notes..."
          
          # Determine the base branch (the target branch of the PR)
          BASE_BRANCH="${{ github.event.pull_request.base.ref }}"
          HEAD_BRANCH="${{ github.event.pull_request.head.ref }}"
          
          echo "Base branch: $BASE_BRANCH"
          echo "Head branch: $HEAD_BRANCH"
          
          echo "Getting latest commits from merged branches..."
          
          # Get all merge commits from this PR
          MERGE_COMMITS=$(git log --merges --pretty=format:"%H" ${{ github.event.pull_request.base.sha }}..${{ github.event.pull_request.head.sha }} 2>/dev/null || echo "")
          
          FORMATTED_COMMITS=""
          PROCESSED_BRANCHES=""
          
          if [ -z "$MERGE_COMMITS" ]; then
            echo "No merge commits found, treating as direct commits to develop"
            # Get the latest actual commit from the PR head (not the PR title)
            LATEST_COMMIT=$(git log --pretty=format:"%h %s" -1 ${{ github.event.pull_request.head.sha }} --no-merges 2>/dev/null || echo "")
            
            if [ -n "$LATEST_COMMIT" ]; then
              HASH=$(echo "$LATEST_COMMIT" | awk '{print $1}')
              MESSAGE=$(echo "$LATEST_COMMIT" | cut -d' ' -f2-)
              
              echo "Direct commit: $HASH $MESSAGE"
              
              # Skip version bump commits
              if [[ "$MESSAGE" =~ ^chore:\ bump\ version ]]; then
                FORMATTED_COMMITS="### No significant commits found"
              else
                # Check if commit has [sc-XXXXX] pattern
                if [[ "$MESSAGE" =~ ^\[sc-[0-9]+\] ]]; then
                  FORMATTED_COMMITS="### $MESSAGE"
                else
                  FORMATTED_COMMITS="### Commits sem ID de tarefa vinculado\n- $MESSAGE"
                fi
              fi
            fi
          else
            echo "Processing merge commits to find latest commit from each branch..."
            
            while IFS= read -r merge_hash; do
              if [ -z "$merge_hash" ]; then
                continue
              fi
              
              echo "Processing merge commit: $merge_hash"
              
              # Get the merge commit message to extract branch info
              MERGE_MESSAGE=$(git log --pretty=format:"%s" -1 $merge_hash 2>/dev/null || echo "")
              
              # Extract branch name from merge message
              BRANCH_NAME=""
              if [[ "$MERGE_MESSAGE" =~ Merge\ branch\ \'([^\']+)\' ]]; then
                BRANCH_NAME="${BASH_REMATCH[1]}"
              elif [[ "$MERGE_MESSAGE" =~ Merge\ pull\ request.*from.*\/([^\ ]+) ]]; then
                BRANCH_NAME="${BASH_REMATCH[1]}"
              fi
              
              if [ -n "$BRANCH_NAME" ]; then
                # Skip if we already processed this branch
                if [[ "$PROCESSED_BRANCHES" =~ $BRANCH_NAME ]]; then
                  continue
                fi
                
                PROCESSED_BRANCHES+=" $BRANCH_NAME"
                
                echo "Getting latest commit from branch: $BRANCH_NAME"
                
                # Get the latest NON-MERGE commit from the merged branch
                # Use the second parent of the merge commit (^2) and get the latest non-merge commit
                LATEST_COMMIT=$(git log --pretty=format:"%h %s" -1 ${merge_hash}^2 --no-merges 2>/dev/null || echo "")
                
                if [ -n "$LATEST_COMMIT" ]; then
                  HASH=$(echo "$LATEST_COMMIT" | awk '{print $1}')
                  MESSAGE=$(echo "$LATEST_COMMIT" | cut -d' ' -f2-)
                  
                  echo "Latest commit from $BRANCH_NAME: $HASH $MESSAGE"
                  
                  # Skip version bump commits
                  if [[ "$MESSAGE" =~ ^chore:\ bump\ version ]]; then
                    echo "Skipping version bump commit"
                    continue
                  fi
                  
                  # Check if commit has [sc-XXXXX] pattern
                  if [[ "$MESSAGE" =~ ^\[sc-[0-9]+\] ]]; then
                    FORMATTED_COMMITS+="\n### $MESSAGE"
                  else
                    # Add to miscellaneous section
                    if [[ ! "$FORMATTED_COMMITS" =~ "### Commits sem ID de tarefa vinculado" ]]; then
                      FORMATTED_COMMITS+="\n### Commits sem ID de tarefa vinculado"
                    fi
                    FORMATTED_COMMITS+="\n- $MESSAGE"
                  fi
                else
                  echo "No commits found for branch: $BRANCH_NAME"
                fi
              else
                echo "Could not extract branch name from merge message: $MERGE_MESSAGE"
              fi
            done <<< "$MERGE_COMMITS"
          fi
          
          # Remove leading newline if present
          FORMATTED_COMMITS=${FORMATTED_COMMITS#\\n}
          
          # If still empty, add a default message
          if [ -z "$FORMATTED_COMMITS" ]; then
            echo "No commits found, using PR title as fallback"
            FORMATTED_COMMITS="### ${{ github.event.pull_request.title }}\n- Merged PR #${{ github.event.pull_request.number }}"
          fi
          
          echo "Final formatted commits:"
          echo -e "$FORMATTED_COMMITS"
          
          # Save to environment variable
          {
            echo 'FORMATTED_COMMITS<<EOF'
            echo -e "$FORMATTED_COMMITS"
            echo 'EOF'
          } >> $GITHUB_ENV

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: "v${{ env.NEW_VERSION }}"
          name: "Release v${{ env.NEW_VERSION }}"
          body: |
            ðŸš€ **Nova versÃ£o ${{ env.NEW_VERSION }} lanÃ§ada!**
            
            **Tipo de release:** ${{ env.BUMP_TYPE }}
            
            ## ðŸ“‹ AlteraÃ§Ãµes
            
            ${{ env.FORMATTED_COMMITS }}
            
            ---
            
            **Merge da PR:** #${{ github.event.pull_request.number }} - ${{ github.event.pull_request.title }}
            **Branch de origem:** ${{ github.event.pull_request.head.ref }}
            **Branch de destino:** ${{ github.event.pull_request.base.ref }}
          draft: false
          prerelease: false
          generate_release_notes: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Summary
        run: |
          echo "### ðŸŽ‰ Release Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Version:** v${{ env.NEW_VERSION }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Bump Type:** ${{ env.BUMP_TYPE }}" >> $GITHUB_STEP_SUMMARY
          echo "- **PR:** #${{ github.event.pull_request.number }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Labels:** ${{ env.PR_LABELS }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Base Branch:** ${{ github.event.pull_request.base.ref }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Head Branch:** ${{ github.event.pull_request.head.ref }}" >> $GITHUB_STEP_SUMMARY
