name: New Release
on:
  pull_request:
    types: [closed]
    branches: [master, main]

permissions:
  pull-requests: write
  contents: write
  actions: read

jobs:
  add-release-label:
    if: github.event.pull_request.merged == true 
    runs-on: ubuntu-latest
    steps:
      - name: Add release label to PR
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              labels: ['release']
            });
            console.log('Added "release" label to PR #' + context.payload.pull_request.number);

  release:
    if: github.event.pull_request.merged == true 
    runs-on: ubuntu-latest
    needs: add-release-label
    steps:
      - name: Check out the repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Get latest tag
        id: get_latest_tag
        run: |
          # Get the latest tag, default to 0.0.0 if no tags exist
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "0.0.0")
          echo "Latest tag found: $LATEST_TAG"
          echo "LATEST_TAG=$LATEST_TAG" >> $GITHUB_ENV

      - name: Get PR labels
        id: get_labels
        run: |
          # Get PR labels using GitHub API
          LABELS=$(gh pr view ${{ github.event.pull_request.number }} --json labels --jq '.labels[].name' | tr '\n' ' ')
          echo "PR Labels: $LABELS"
          echo "PR_LABELS=$LABELS" >> $GITHUB_ENV
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Determine version bump type
        id: determine_bump
        run: |
          BUMP_TYPE="patch"
          
          # Check for version bump labels
          if echo "${{ env.PR_LABELS }}" | grep -q "major\|breaking"; then
            BUMP_TYPE="major"
          elif echo "${{ env.PR_LABELS }}" | grep -q "minor\|feature"; then
            BUMP_TYPE="minor"
          elif echo "${{ env.PR_LABELS }}" | grep -q "patch\|fix\|bugfix"; then
            BUMP_TYPE="patch"
          fi
          
          echo "Version bump type: $BUMP_TYPE"
          echo "BUMP_TYPE=$BUMP_TYPE" >> $GITHUB_ENV

      - name: Calculate new version
        id: calc_version
        run: |
          # Parse current version
          CURRENT_VERSION="${{ env.LATEST_TAG }}"
          # Remove 'v' prefix if present
          CURRENT_VERSION=${CURRENT_VERSION#v}
          
          # Split version into components
          IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
          MAJOR=${VERSION_PARTS[0]:-0}
          MINOR=${VERSION_PARTS[1]:-0}
          PATCH=${VERSION_PARTS[2]:-0}
          
          # Bump version based on type
          case "${{ env.BUMP_TYPE }}" in
            "major")
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            "minor")
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            "patch")
              PATCH=$((PATCH + 1))
              ;;
          esac
          
          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          echo "New version: $NEW_VERSION"
          echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_ENV

      - name: Get commits for release notes
        id: get_commits
        run: |
          echo "Getting commits for release notes..."
          
          # Determine the base branch (the target branch of the PR)
          BASE_BRANCH="${{ github.event.pull_request.base.ref }}"
          HEAD_BRANCH="${{ github.event.pull_request.head.ref }}"
          
          echo "Base branch: $BASE_BRANCH"
          echo "Head branch: $HEAD_BRANCH"
          
          echo "Getting commits from this PR only..."
          
          # Get all merge commits from this specific PR range
          MERGE_COMMITS=$(git log --merges --pretty=format:"%H" ${{ github.event.pull_request.base.sha }}..${{ github.event.pull_request.head.sha }} 2>/dev/null || echo "")
          
          FORMATTED_COMMITS=""
          PROCESSED_BRANCHES=""
          
          if [ -z "$MERGE_COMMITS" ]; then
            echo "No merge commits found, treating as direct commits to develop"
            # Get commits from this PR only (between base and head)
            ALL_COMMITS=$(git log --pretty=format:"%h %s" ${{ github.event.pull_request.base.sha }}..${{ github.event.pull_request.head.sha }} --no-merges --reverse 2>/dev/null || echo "")
            
            if [ -n "$ALL_COMMITS" ]; then
              # Filter out version bump commits
              FILTERED_COMMITS=$(echo "$ALL_COMMITS" | grep -v "^[a-f0-9]* chore: bump version")
              
              if [ -n "$FILTERED_COMMITS" ]; then
                # Get the latest commit as title
                LATEST_COMMIT=$(echo "$FILTERED_COMMITS" | tail -1)
                LATEST_MESSAGE=$(echo "$LATEST_COMMIT" | cut -d' ' -f2-)
                
                FORMATTED_COMMITS="$LATEST_MESSAGE"
                
                # Add other commits as bullet points (if any)
                OTHER_COMMITS=$(echo "$FILTERED_COMMITS" | head -n -1)
                if [ -n "$OTHER_COMMITS" ]; then
                  while IFS= read -r commit; do
                    if [ -n "$commit" ]; then
                      COMMIT_MESSAGE=$(echo "$commit" | cut -d' ' -f2-)
                      FORMATTED_COMMITS+="\n- $COMMIT_MESSAGE"
                    fi
                  done <<< "$OTHER_COMMITS"
                fi
              fi
            fi
          else
            echo "Processing merge commits from this PR..."
            
            while IFS= read -r merge_hash; do
              if [ -z "$merge_hash" ]; then
                continue
              fi
              
              echo "Processing merge commit: $merge_hash"
              
              # Get the merge commit message to extract branch info
              MERGE_MESSAGE=$(git log --pretty=format:"%s" -1 $merge_hash 2>/dev/null || echo "")
              
              # Extract branch name from merge message
              BRANCH_NAME=""
              if [[ "$MERGE_MESSAGE" =~ Merge\ branch\ \'([^\']+)\' ]]; then
                BRANCH_NAME="${BASH_REMATCH[1]}"
              elif [[ "$MERGE_MESSAGE" =~ Merge\ pull\ request.*from.*\/([^\ ]+) ]]; then
                BRANCH_NAME="${BASH_REMATCH[1]}"
              fi
              
              if [ -n "$BRANCH_NAME" ]; then
                # Skip if we already processed this branch
                if [[ "$PROCESSED_BRANCHES" =~ $BRANCH_NAME ]]; then
                  continue
                fi
                
                PROCESSED_BRANCHES+=" $BRANCH_NAME"
                
                echo "Getting commits from merged branch: $BRANCH_NAME"
                
                # Get commits from the merged branch only (commits that were merged in this specific merge)
                # Use the merge base to find only the commits that were added by this branch
                MERGE_BASE=$(git merge-base ${merge_hash}^1 ${merge_hash}^2 2>/dev/null || echo "")
                
                if [ -n "$MERGE_BASE" ]; then
                  # Get commits between merge base and the tip of the merged branch
                  ALL_BRANCH_COMMITS=$(git log --pretty=format:"%h %s" ${MERGE_BASE}..${merge_hash}^2 --no-merges --reverse 2>/dev/null || echo "")
                else
                  # Fallback: get commits from the second parent (merged branch)
                  ALL_BRANCH_COMMITS=$(git log --pretty=format:"%h %s" ${merge_hash}^2 --no-merges --reverse --max-count=10 2>/dev/null || echo "")
                fi
                
                if [ -n "$ALL_BRANCH_COMMITS" ]; then
                  # Filter out version bump commits only
                  FILTERED_BRANCH_COMMITS=$(echo "$ALL_BRANCH_COMMITS" | grep -v "^[a-f0-9]* chore: bump version")
                  
                  if [ -n "$FILTERED_BRANCH_COMMITS" ]; then
                    # Get the latest commit as title (last in chronological order)
                    LATEST_COMMIT=$(echo "$FILTERED_BRANCH_COMMITS" | tail -1)
                    LATEST_MESSAGE=$(echo "$LATEST_COMMIT" | cut -d' ' -f2-)
                    
                    echo "Latest commit from $BRANCH_NAME: $LATEST_MESSAGE"
                    
                    # Add section for this branch
                    if [ -n "$FORMATTED_COMMITS" ]; then
                      FORMATTED_COMMITS+="\n\n"
                    fi
                    FORMATTED_COMMITS+="$LATEST_MESSAGE"
                    
                    # Add other commits as bullet points (if any)
                    OTHER_COMMITS=$(echo "$FILTERED_BRANCH_COMMITS" | head -n -1)
                    if [ -n "$OTHER_COMMITS" ]; then
                      while IFS= read -r commit; do
                        if [ -n "$commit" ]; then
                          COMMIT_MESSAGE=$(echo "$commit" | cut -d' ' -f2-)
                          FORMATTED_COMMITS+="\n- $COMMIT_MESSAGE"
                        fi
                      done <<< "$OTHER_COMMITS"
                    fi
                  else
                    echo "No valid commits found for branch: $BRANCH_NAME (after filtering version bumps)"
                  fi
                else
                  echo "No commits found for branch: $BRANCH_NAME"
                fi
              else
                echo "Could not extract branch name from merge message: $MERGE_MESSAGE"
              fi
            done <<< "$MERGE_COMMITS"
          fi
          
          # Remove leading newline if present
          FORMATTED_COMMITS=${FORMATTED_COMMITS#\\n}
          
          # If still empty, add a default message
          if [ -z "$FORMATTED_COMMITS" ]; then
            echo "No commits found in this PR, using PR title as fallback"
            FORMATTED_COMMITS="### ${{ github.event.pull_request.title }}\n- Merged PR #${{ github.event.pull_request.number }}"
          fi
          
          echo "Final formatted commits:"
          echo -e "$FORMATTED_COMMITS"
          
          # Save to environment variable
          {
            echo 'FORMATTED_COMMITS<<EOF'
            echo -e "$FORMATTED_COMMITS"
            echo 'EOF'
          } >> $GITHUB_ENV

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: "v${{ env.NEW_VERSION }}"
          name: "Release v${{ env.NEW_VERSION }}"
          body: |
            🚀 **Nova versão ${{ env.NEW_VERSION }} lançada!**
            
            **Tipo de release:** ${{ env.BUMP_TYPE }}
            
            ## 📋 Alterações
            
            ${{ env.FORMATTED_COMMITS }}
            
            ---
            
            **Merge da PR:** #${{ github.event.pull_request.number }} - ${{ github.event.pull_request.title }}
            **Branch de origem:** ${{ github.event.pull_request.head.ref }}
            **Branch de destino:** ${{ github.event.pull_request.base.ref }}
          draft: false
          prerelease: false
          generate_release_notes: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Summary
        run: |
          echo "### 🎉 Release Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Version:** v${{ env.NEW_VERSION }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Bump Type:** ${{ env.BUMP_TYPE }}" >> $GITHUB_STEP_SUMMARY
          echo "- **PR:** #${{ github.event.pull_request.number }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Labels:** ${{ env.PR_LABELS }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Base Branch:** ${{ github.event.pull_request.base.ref }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Head Branch:** ${{ github.event.pull_request.head.ref }}" >> $GITHUB_STEP_SUMMARY
